## 1. 동기화 & 비동기화
### 1.1 개요
흔히 클라이언트와 서버 사이에 소켓통신 용어로 사용 되지만 일반적인 프로그래밍에서도 많이 사용됩니다.<br>
이 글에선 일반적인 프로그래밍의 동기화 & 비동기화에 대해 다룹니다. <br>
동기화와 비동기화는 아래와 같이 간단히 정리해 볼 수 있습니다. <br>
* 동기화
  * 블럭(Block), 프로세서에서 특정 값을 처리하여 그 결과값을 받기 전까지 무한정 기다립니다. 
* 비동기화
  * 논블럭(Non-block), 프로세서에서 특정 값을 처리하여 그 결과값을 기다리지 않고 다음 작업을 진행 합니다.
<br>
대부분의 개발자들은 특정 값을 처리하여 사용할때 위 두 개념을 항상 염두해두고 개발을 했을겁니다. 프로젝트가 복잡해지고 처리된 값을 사용자에게 보여줘야할 경우 그 값의 무결성(data integrity)을 개발자는 항상 보증해줘야 하지만 각기 다른 처리주기를 가지는 쓰레드를 동시에 관리한다는 것은 무척 어려운 일 이며 무결성을 떠나 프로그램이 교착상태에 빠져버릴 위험도 있습니다.
<br><br>
비동기화에 대한 예를 들어 보면 자동차를 운전할 경우 시동을 걸어 엔진을 가동시키면 엔진은 계속해서 동력을 공급하고 이 동력을 기반으로 다른 부품 기능들이 동작하게 됩니다. 엔진은 동력을 공급할때 다른 부품들이 자신이 생산한 동력을 잘 받았는지 확인하지 않습니다. 엔진이 생산한 동력을 다른 부품이 잘 받았는지 확인하고 다음 동력을 생산하도록 로직을 짠다면 동력을 늦게 전달받은 마지막 부품의 확인이 끝날때 까지 아무런 동작을 할 수 없을 것이고 자동차는 멈췄다 섯다를 반복하며 이동하게 될 것입니다.  
<br><br>
동기화 예를 들어보겠습니다. 음료수 자판기가 있고 사용자는 돈을 투입하여 자판기를 사용합니다. 자판기는 사용자가 음료수를 선택할때까지 무한정 대기해야 합니다. 사용자가 음료수를 선택하면 어떤걸 선택했는지 확인하고 음료수를 출고 시키죠.

<pre><code>

Thread mChooseDrink = new Thread(new Runnable {
   void run() {
      while(true){
         ...
         int selectPosition = didyouchoose(); // 사용자가 선택했는지 확인 합니다.
         if(getItem(selectPosition)) break;   // 사용자가 선택한 값이 처리되면 반복문을 종료합니다.
      }
   }
}

...

main() {
   mChooseDrink.start();
}

...
</pre></code>

위 코드에서 didyouchoose() 라는 함수로 사용자가 선택 할때까지 계속해서 반복하며 확인할 것 입니다. <br>
<br>
자판기 : 골랏니?<br>
사용자 : 아니<br>
자판기 : 골랏니?<br>
사용자 : 아니<br>
자판기 : 골랏니?<br>
사용자 : 아니<br>
자판기 : 골랏니?<br>
사용자 : 아니, 좀 기다려봐<br>
자판기 : 골랏니?<br>
사용자 : .....아니<br>
<br>
물론, 자판기가 사용자에게 직접 물어보진 않겠지만 ChooseDrink Thread는 그 작업을 하고 있습니다. 선택할때까지요.
<br>


